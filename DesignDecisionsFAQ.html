<!-- Generated automatically - edit the templates! -->

<!DOCTYPE html>

<html>
<head>

<title>Design decisions FAQ - Better Enums</title>

<link rel="canonical" href="http://aantron.github.io/better-enums/DesignDecisionsFAQ.html" />
<meta name="description" content="Better Enums design decisions and tradeoffs." />
<meta name="author" content="Anton Bachin" />

<meta name="viewport" content="width=device-width" />

<link rel="stylesheet" href="better-enums.css" />

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-62962513-1', 'auto');
  ga('send', 'pageview');

</script>

</head>
<body class="">

<nav>
  <div class="container">
    <a class="first" href="https://raw.githubusercontent.com/aantron/better-enums/0.10.0/enum.h"
download>Download</a>
    <a href="https://github.com/aantron/better-enums">GitHub</a>
    <a href="index.html">Home</a>
    <a href="tutorial/HelloWorld.html">Tutorial</a>
    <a href="ApiReference.html">Reference</a>
    <a href="Contact.html">Contact</a>
  </div>
</nav>

<div class="spacer">&nbsp;</div>

<header>
  <div class="container">
    <section>
      <h1><a href="index.html">Better Enums</a></h1>
      <h2>Reflective compile-time enums for <span class="cpp">C++</span></h2>
      <h3>Open-source under the BSD license</h3>
    </section>

    <section class="notes">
      <p>Version 0.10.0</p>
      <p>To install, just add <code>enum.h</code> to your project.</p>
      <p>
        Visit the GitHub repo for issues, feedback, and the latest development.
      </p>
    </section>

    <section class="buttons">
      <a href="https://raw.githubusercontent.com/aantron/better-enums/0.10.0/enum.h"
download>Download <code>enum.h</code></a>
      <a href="https://github.com/aantron/better-enums">GitHub</a>
    </section>
  </div>
</header>

<div class="buttons-bar">
  <div class="container">
    <a href="https://twitter.com/intent/tweet?related=better_enums&screen_name=better_enums&share_with_retweet=never&tw_p=tweetbutton">
  <img src="image/twsupport.png" alt="Tweet for suport"></img>
</a>
  </div>
</div>

<div class="main">
  <div class="container">


<h2>Design decisions FAQ</h2>
<p><span class="self">Better Enums</span> pushes at the edges of what is possible in standard <span class="cpp">C++</span>, and I've had to
make some difficult decisions as a result. You can imagine the set of
potential reflective enum implementations as a space, with axes such as "concise
syntax," "uniform interface," "compilation speed," "run-time performance," and
so on. As is typical in engineering, the constraints are such that as you move
to extremes along one axis, you have to retreat along others &mdash; for
example, some desirable aspects of concise syntax conflict with having a uniform
interface, which is nonetheless good for teachability, and compile-time
performance is, in some ways, at odds with run-time performance.</p>
<p>So, there are many variations possible on <span class="self">Better Enums</span>, and, in fact, I have tried and
maintained a few. This page describes how I chose the one that is published.
The choices are debatable, but I am attempting to record the debate. Hopefully,
this will either convince you that I have made a good choice, or, if you
disagree, you will have a good starting point for discussion, or even for
implementing an alternative.</p>
<p>I am always looking for new arguments and approaches. If you have an idea,
comment, criticism, please do <a href="Contact.html">let me know</a>.</p>
<p><a id="contents"></a><h3 class="contents">Contents</h3><ul class="contents"><li><a href="#WhyDoEnumMembersHaveUnderscores">Why do enum members have underscores?</a></li><li><a href="#WhyDoesBetterEnumsUseAMacroAtAll">Why does Better Enums use a macro at all?</a></li><li><a href="#WhyIsItNotPossibleToDeclareABetterEnumInsideAClass">Why is it not possible to declare a Better Enum inside a class?</a></li><li><a href="#ShouldBetterEnumsProvideEnum"objects"OrTraitsTypes">Should Better Enums provide enum "objects" or traits types?</a></li><li><a href="#WhyDoesBetterEnumsUseLinearScansForLookup">Why does Better Enums use linear scans for lookup?</a></li></ul></p>
<a id="WhyDoEnumMembersHaveUnderscores"></a><h3>Why do enum members have underscores?</h3>
<p>Enum members such as <code>_to_string</code> occupy the same scope as the names of
constants declared by the user. I chose to prefix members with underscores to
lessen the chances of collision. For example, take <code>_valid</code>, and suppose it was
<code>valid</code> instead. That would make this enum impossible:</p>
<pre><em>ENUM(Status, char, valid, invalid)</em></pre><p>because the constant <code>Status::valid</code> would clash with the member
<code>Status::valid</code>.</p>
<p>Of course, users could try to declare constants with underscores as well, but I
find it easier to ask users not to do that, rather than ask them to worry about
a potentially growing set of reserved names, which they wouldn't fully know even
for a single version of Better Enums, without frequently looking at the API
documentation.</p>
<p>Alternatives to this involve separating the namespaces occupied by members and
constants. I don't think increasing nesting is an option, since nobody wants to
write <code>Status::values::valid</code> or <code>Status::operations::valid</code>. I don't think
moving constants out of <code>Status</code> is a good idea, since scoped constants is a
feature of Better Enums, which is especially important for <span class="cpp">C++</span><span class="eleven">98</span> usage.</p>
<p>This leaves the possibility of moving the operations performed by the members
into traits types, i.e. something like <code>traits&lt;Status&gt;::valid</code>. That is an
interesting option, and it has <a href="#Traits">its own section</a>. I have tried it, but
the verbosity increase is much greater than the benefit of dropping underscores,
so I chose not to do it.</p>
<a id="WhyDoesBetterEnumsUseAMacroAtAll"></a><h3>Why does Better Enums use a macro at all?</h3>
<p>Better Enums needs to turn the names of declared constants into strings, and I
don't believe there is any way to do this in standard <span class="cpp">C++</span> except by using the
preprocessor's macro parameter stringization operator (<code>#</code>). So, at the top
level, Better Enums has to provide a macro. I am, however, trying to keep the
user-facing macros to a minimum; in particular there is only one.</p>
<p>I think that's the best that is possible. Furthermore, apart from the macro
itself, the declaration looks very similar to a <span class="cpp">C++</span><span class="eleven">11</span> <code>enum</code> declaration, with
an underlying type, comma-separated constant list, and the same support for
initializers as built-in enums. So, I am trying to keep even this one macro out
of the user's way. I wouldn't accept any change that involved turning the
declaration into a preprocessor sequence or tuple, i.e. something like</p>
<pre><em>ENUM(Channel, int, (Red)(Green)((Blue)(5)))</em></pre><p>even if it promised extra capabilities.</p>
<p>Better Enums uses additional macros internally, for two main purposes: to do the
actual work of stringizing the declared constants and assembling them into
arrays, and to configure itself by detecting which compiler it is running on.</p>
<p>I am not a fan of gratuitous macros, but in these cases they are unavoidable,
and, indeed, I am grateful for the stringization operator.</p>
<p><a id="NoEnumInsideClass"></a></p>
<a id="WhyIsItNotPossibleToDeclareABetterEnumInsideAClass"></a><h3>Why is it not possible to declare a Better Enum inside a class?</h3>
<p>This is due to an interaction between linkage and <code>constexpr</code>.</p>
<ol>
<li><p>Better Enums is a header-only library that declares arrays with static
storage, such as the array of constant names for each declared enum. Such
arrays can be declared in namespace scope, in class scope, or in function
scope, but they also need to be defined somewhere.</p>
<p>If <code>ENUM</code> is to be usable in both namespace and class scope, it already can't
assume that it can declare arrays in namespace scope, since if <code>ENUM</code> is used
in a class, its entire expansion will be enclosed in the declaration of that
class.</p>
<p>That leaves class scope and function scope. If the arrays are declared in
class scope, there needs to be a separate definition of them in some
translation unit. This is too burdensome for the user, because the separate
definition would involve repetition of the constants in the macro parameter
list, creating exactly the type of maintenance problem that Better Enums is
trying to eliminate.</p>
<p>Function scope is the only viable option remaining after considering linkage
constraints. Each array can be wrapped in a static function, which has a
static local variable, which is initialized with the array. The functions can
be called to get references to the arrays.</p>
<p>However....</p>
</li>
<li><p>These arrays need to be accessible to <code>constexpr</code> code in <span class="cpp">C++</span><span class="eleven">11</span>, and
<code>constexpr</code> functions are not allowed to have static local variables.</p>
</li>
</ol>
<p>Ironically, this seems like one place where <span class="cpp">C++</span><span class="eleven">98</span> is more "flexible," but only
for the reason that compile-time usage of Better Enums is not supported in
<span class="cpp">C++</span><span class="eleven">98</span>.</p>
<p><a id="Traits"></a></p>
<a id="ShouldBetterEnumsProvideEnum"objects"OrTraitsTypes"></a><h3>Should Better Enums provide enum "objects" or traits types?</h3>
<p>A Better Enum value is an "object," whose memory representation is the same as
its underlying type. For example,</p>
<pre><em>ENUM(Channel, int, Red, Green, Blue)</em></pre><p>expands to something like</p>
<pre><em>struct Channel {
    enum _enumerated : int { Red, Green, Blue };
    int _value;</em>
    // Strings array, _to_string, _from_string, etc.
<em>};</em></pre><hr>
<p>There is an alternative interpretation, in which the Better Enums library
generates enum traits instead, i.e. the generated arrays and members sit
alongside built-in enums instead of wrapping them:</p>
<pre><em>ENUM(Channel, int, Red, Green, Blue)</em></pre><p>generates</p>
<pre><em>enum class Channel : int { Red, Green, Blue };</em>

<em>template &lt;&gt;
struct ::better_enums::traits&lt;Channel&gt; {
    using _enumerated = Channel;</em>
    // Strings array, to_string, from_string, etc.
<em>};</em></pre><hr>
<p>There are a number of advantages to the traits approach.</p>
<ul>
<li>The underscore prefixes can be dropped from member names, since they no longer
share a namespace with user-declared constants.</li>
<li>The interface, at first glance, becomes more uniform, since now every member
is a static member of the traits type. Without traits, <code>_to_string</code> is a
non-static member, while <code>_from_string</code> is a static member.</li>
<li><code>Channel</code> is one of the language's own enum types, instead of some mystery
type provided by Better Enums. This may make it easier to understand. It also
eliminates the problem with different syntaxes for <code>switch</code> statements
described <a href="OptInFeatures.html#StrictConversions">here</a>.</li>
</ul>
<p>However, it also introduces some difficulties.</p>
<ul>
<li>The syntax is more verbose, since everything becomes a member of the traits
type. For example, instead of <code>Channel::_from_string()</code>, you get
<code>better_enums::traits&lt;Channel&gt;::from_string()</code>. The underscore may be
unpleasant, but so far I have preferred the underscore to boilerplate.</li>
<li><p>The uniform interface ends up getting wrapped behind functions anyway, for the
sake of type inference. For example, the "naked" <code>to_string</code> function is
called as <code>better_enums::traits&lt;Channel&gt;::to_string(channel)</code>, which is
redundant, because the compiler could infer the type parameter <code>Channel</code> if it
was the parameter of the function instead of the traits type. So, the obvious
thing is to define such a wrapper function, which can then be called as
<code>better_enums::to_string(channel)</code>. No such function can be easily defined for
<code>from_string</code> and other <code>from_*</code> functions, however, because the type
parameters can't be inferred from arguments. So, the signatures of <code>to_*</code> and
<code>from_*</code> functions again effectively diverge, negating this advantage of
traits. The closest I can get with wrappers is
<code>better_enums::from_string&lt;Channel&gt;</code>, which has the same signature only in the
formal sense, i.e. modulo the difference in type inference.</p>
<p>I actually think there is a way to infer the type parameter from the return
type, similar to how it is done <a href="demo/SpecialValues.html">here</a>, but that will not be suitable
for all contexts, and the user may be surprised by ambiguous resolution error
messages when it is not.</p>
</li>
<li>The experimental feature presented <a href="demo/NonIntegralUnderlyingTypes.html">here</a> would be questionable in
the traits interpretation. It is still possible to have a non-integral
underlying type with traits, but it would be strange if the traits version of
the macro accepted a non-integral underlying type, and then declared the
actual language enum with an integral underlying type. Even though that is
exactly what the non-traits version does, there the language enum is hidden
inside the generated type, instead of being exposed alongside a traits type.</li>
<li>Scoped constants are lost for <span class="cpp">C++</span><span class="eleven">98</span> unless Better Enums again wraps them in a
generated type, though it will be more lightweight than a full Better Enum of
the non-traits approach.</li>
<li>Traits types are not intuitive for some <span class="cpp">C++</span> users, which would present a
barrier to usage.</li>
</ul>
<p>Despite the disadvantages listed just above, I consider the traits approach
interesting &mdash; it's a close call. There is an
<a href="https://github.com/aantron/better-enums/tree/traits">out-of-date branch</a> containing a traits version of Better Enums.
You can see some of the usage in its <a href="https://github.com/aantron/better-enums/tree/traits/samples">samples</a> directory. I may
update it from time to time, especially if there is interest.</p>
<a id="WhyDoesBetterEnumsUseLinearScansForLookup"></a><h3>Why does Better Enums use linear scans for lookup?</h3>
<p>It seems that Better Enums needs to use the same algorithms at compile time as
at run time, because I have not found a way (and doubt there is one) to
determine, during the execution of a <code>constexpr</code> function, whether it is
executing at compile time or at run time. So, whatever data structures I use to
accelerate lookup, I have to generate them at compile time, to be available as
early as possible.</p>
<p>I tried to generate various data structures at compile time, but so far,
generation has been too slow. The fastest algorithm so far, a compile-time merge
sort based on template parameter packs, took over 100ms to run on the constant
set of a large enum. I would have to run three of these per enum &mdash; for the
constants, for the names, and for the names with case-insensitive comparison.
This results in a 300ms slowdown per enum, which is not acceptable, given that
on my system the same compiler takes 370ms to process <code>iostream</code>, and less than
10ms to process an enum without acceleration data structures. Declaring five
large enums with accelerated lookup would take 1.5 seconds of compilation time.
This doesn't scale to large projects with many translation units.</p>
<p>I am continuing to look for faster algorithms or better approaches, so faster
lookup may be coming to Better Enums in the future.</p>
<p>So far, I have tried Boost.MPL sort, Eric Niebler's Meta sort, my own selection
sort based on <code>constexpr</code>, and an insertion and merge sort based on parameter
packs. I cannot use (Boost?).Hana sort, because that requires <span class="cpp">C++</span><span class="eleven">14</span>. I am also
considering various hash table-like data structures, and providing two sets of
interfaces for compile-time and run-time usage, which is something I would
really rather not have to do. The latter option would be worth considering,
however, if I measured a significant improvement in running time from better
data structures &mdash; something I haven't gotten to yet because there doesn't
seem to be a data structure to measure that is not disqualified by the speed of
generation.</p>


  </div>
</div>

<footer>
  <div class="container">
    Copyright &copy; 2015 Anton Bachin. Released under the BSD 2-clause license.
    See <a href="https://github.com/aantron/better-enums/blob/master/LICENSE">
    LICENSE</a>.
    <br />
    This page is part of the documentation for Better Enums 0.10.0.
  </div>
</footer>

</body>
</html>

